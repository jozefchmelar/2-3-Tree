/*                val deletedKv = delKev!!
                //al de
                //ok let's delete some stuff
                *//*.
                node element otca lavy +  pravy + lavz szn + middle syn + right syn lebo ak je sucet 4 vies to spravit
                a ak je to viac ako 5 tiez to vies hned spravit a iba
                ak je ich menej ako 4 idem do metody kde riesim tieto restrukturalizacne veci ...
                 *//*
                val deleteNodeParent= deleteNode.parent
                var keyValuesCount=0
                when(deleteNodeParent){
                    is Node.TwoNode   -> {
                        keyValuesCount++
                        when(deleteNodeParent.left){
                            is Node.TwoNode   -> keyValuesCount++
                            is Node.ThreeNode -> keyValuesCount+=2
                        }
                        when(deleteNodeParent.right){
                            is Node.TwoNode   -> keyValuesCount++
                            is Node.ThreeNode -> keyValuesCount+=2
                        }
                    }

                    is Node.ThreeNode -> {
                        keyValuesCount+=2
                        when(deleteNodeParent.left){
                            is Node.TwoNode   -> keyValuesCount++
                            is Node.ThreeNode -> keyValuesCount+=2
                        }
                        when(deleteNodeParent.middle){
                            is Node.TwoNode   -> keyValuesCount++
                            is Node.ThreeNode -> keyValuesCount+=2
                        }
                        when(deleteNodeParent.right){
                            is Node.TwoNode   -> keyValuesCount++
                            is Node.ThreeNode -> keyValuesCount+=2
                        }
                    }

                }

                if(keyValuesCount >= 4 ){
                    when(deleteNodeParent){
                        is Node.TwoNode   -> when(deleteNode){
                            is Node.TwoNode   -> {
                                val sibling = deleteNode.getSiblings().closestSibling()
                                when(sibling.getPosition()){
                                    Left   -> {
                                        (sibling as ThreeNode).deleteFromNode(sibling.keyValue2.key)
                                        deleteNode.keyValue1=deleteNodeParent.keyValue1
                                        deleteNodeParent.keyValue1=sibling.keyValue2
                                        return true
                                    }
                                    Middle -> throw IllegalStateException()
                                    Right  -> {
                                        (sibling as ThreeNode).deleteFromNode(sibling.keyValue1.key)
                                        deleteNodeParent.keyValue1=sibling.keyValue1
                                        return true
                                    }
                                }

                            }
                            is Node.ThreeNode -> {
                                if( deleteNode.left    == inorderSuccessorNode ||
                                    deleteNode.middle  == inorderSuccessorNode ||
                                    deleteNode.right   == inorderSuccessorNode ) {
                                    when (inorderSuccessorNode.getPosition()) {
                                        Left -> TODO()
                                        Middle -> {
                                            val siblings = inorderSuccessorNode.getSiblings() as Sibling.TwoSiblings
                                            if(siblings.hasThreeNodeSibling()){
                                                if(siblings.twoThreeNodeSiblings()){
                                                    val delKv1=deleteNode.keyValue1
                                                    deleteNode.keyValue1=(siblings.closestSibling() as ThreeNode).keyValue2
                                                    deleteNode.middle!!.keyValue1=delKv1
                                                    (siblings.closestSibling() as ThreeNode).deleteFromNode(deleteNode.keyValue1.key)
                                                    return true
                                                }
                                                val newM = deleteNode.keyValue2
                                                val newP = (siblings.second as ThreeNode).keyValue1
                                                deleteNode.keyValue2=newP
                                                inorderSuccessorNode.keyValue1=newM
                                                (siblings.second as ThreeNode).deleteFromNode(newP.key)
                                                return true
                                            }else{
                                                if(inorderSuccessorNode is TwoNode){
                                                deleteNode.replaceWith(
                                                    TwoNode(deleteNode.keyValue2, parent = deleteNodeParent)
                                                        .addLeft(ThreeNode(deleteNode.left!!.keyValue1, deleteNode.keyValue1))
                                                        .addRight(deleteNode.right!!)
                                                )
                                                return true}else{
                                                    (inorderSuccessorNode as ThreeNode).deleteFromNode(key)
                                                    return true
                                                }
                                            }

                               *//*             if (siblings.hasNotThreeNodeSibling()) {
                                            //TODO IF inorderSuccesrNode is TwoNode.... takt toto co mam, inak else a daco spravit
                                                if(inorderSuccessorNode is TwoNode)
                                                    deleteNode.replaceWith(
                                                        TwoNode(deleteNode.keyValue2, parent = deleteNodeParent)
                                                            .addLeft(ThreeNode(deleteNode.left!!.keyValue1, deleteNode.keyValue1))
                                                            .addRight(deleteNode.right!!)
                                                    )
                                                else
                                                {
                                                    (inorderSuccessorNode as ThreeNode).deleteFromNode(key)
                                                 }
                                                return true
                                            } else if (siblings.hasThreeNodeSibling()) {
                                                val sibling = siblings.closestSibling() as ThreeNode
                                                when(sibling.getPosition()){
                                                    Left   -> {
                                                        val delKv1=deleteNode.keyValue1
                                                        deleteNode.keyValue1=sibling.keyValue2
                                                        deleteNode.middle!!.keyValue1=delKv1
                                                        sibling.deleteFromNode(deleteNode.keyValue1.key)
                                                        return true
                                                    }
                                                    Middle -> TODO()
                                                    Right  -> TODO()
                                                }
                                            }*//*

                                        }
                                        Right -> {
                                            val siblings = inorderSuccessorNode.getSiblings().closestSibling()
                                            if(inorderSuccessorNode is ThreeNode){
                                                val newP = inorderSuccessorNode.keyValue1
                                                deleteNode.keyValue2=inorderSuccessorKv
                                                inorderSuccessorNode.deleteFromNode(inorderSuccessorNode.keyValue1.key)
                                                return true
                                            }
                                            if (siblings is TwoNode) {
                                                deleteNode.replaceWith(
                                                    TwoNode(deleteNode.keyValue1, parent = deleteNodeParent)
                                                        .addLeft(deleteNode.left!!)
                                                        .addRight(ThreeNode(deleteNode.middle!!.keyValue1, deleteNode.keyValue2))
                                                )
                                                return true
                                            }else {
                                                val newParentKv = (siblings as ThreeNode).keyValue2
                                                val newRightKv = deleteNode.keyValue2
                                                inorderSuccessorNode.keyValue1=newRightKv
                                                deleteNode.keyValue2=newParentKv
                                                siblings.deleteFromNode(newParentKv.key)
                                                return true

                                            }
                                        }
                                    }
                                }else TODO()


                            }
                        }

                        is Node.ThreeNode -> when(deleteNode){
                            is Node.TwoNode   -> {
                                when(deleteNode.getPosition()){
                                    Left   -> {
                                        val sibling = deleteNode.getSiblings().closestSibling()
                                        if(sibling is TwoNode){
                                        deleteNodeParent.replaceWith(
                                            TwoNode(keyValue1 = deleteNodeParent.keyValue2, parent = deleteNodeParent.parent)
                                                .addLeft(ThreeNode(inorderSuccessorKv,deleteNodeParent.middle!!.keyValue1))
                                                .addRight(deleteNodeParent.right!!)
                                        )
                                        return true}else{
                                            val pKv=sibling.keyValue1
                                            deleteNodeParent.keyValue1 = pKv
                                            (sibling as ThreeNode).deleteFromNode(pKv.key)
                                            return true
                                        }
                                    }
                                    Middle -> {

                                        val siblings = deleteNode.getSiblings() as Sibling.TwoSiblings
                                        if (siblings.hasThreeNodeSibling()) {
                                            if (siblings.twoThreeNodeSiblings()) {
                                                deleteNodeParent.keyValue2=inorderSuccessorKv
                                                deleteNode.keyValue1=deleteNodeParent.keyValue1
                                                val sibling = siblings.first as ThreeNode
                                                deleteNodeParent.keyValue1=sibling.keyValue2
                                                sibling.deleteFromNode( deleteNodeParent.keyValue1.key)
                                                return true
                                            }
                                            val sibling = siblings.second
                                            deleteNodeParent.keyValue2=sibling.keyValue1
                                            (sibling as ThreeNode).deleteFromNode(sibling.keyValue1.key)
                                            return true
                                        } else if (siblings.closestSibling() is TwoNode) {
                                            deleteNodeParent.replaceWith(
                                                TwoNode(keyValue1 = deleteNodeParent.keyValue1, parent = deleteNodeParent.parent)
                                                    .addLeft(deleteNodeParent.left!!)
                                                    .addRight(ThreeNode(inorderSuccessorKv, deleteNodeParent.right!!.keyValue1))
                                            )
                                            return true
                                        } else {
                                            TODO()

                                        }
                                    }
                                    Right  -> {
                                        val sibling = deleteNode.getSiblings().closestSibling()
                                        if (sibling is TwoNode) {
                                            deleteNodeParent.replaceWith(
                                                TwoNode(keyValue1 = deleteNodeParent.keyValue1, parent = deleteNodeParent.parent)
                                                    .addLeft(deleteNodeParent.left!!)
                                                    .addRight(ThreeNode(deleteNodeParent.middle!!.keyValue1, deleteNodeParent.keyValue2))
                                            )
                                            return true
                                        } else {
                                            val newRight  = deleteNodeParent.keyValue2
                                            val newParent = (sibling as ThreeNode).keyValue2

                                            inorderSuccessorNode.keyValue1=newRight
                                            deleteNodeParent.keyValue2=newParent
                                            sibling.deleteFromNode(newParent.key)
                                            return true
                                        }
                                    }
                                }

                            }
                            is Node.ThreeNode ->TODO()
                        }
                    }

                }else{
                    var i = 0
                    while(true){
                        if (i++ > 40) throw Exception("loop")

                    }
                }
                *//*
                1. Locate node n, which contains item I
                2. If node n is not a leaf  swap I with inorder successor
                 deletion always begins at a leaf
                3. If leaf node n contains another item, just delete item I
                    else
                try to redistribute nodes from siblings (see next slide)
                if not possible, merge node (see next slide)
                Del
                 *//*
                TODO()
                var i = 0
                while (inorderSuccessorNode != null) {
                    if (i++ > 40) throw Exception("loop")
                }*/

/* posledny smutny pokus
                    if(node.hasKids()){
//                        when(node){
//                            is Node.TwoNode        -> node.replaceWith(TwoNode(inorderSuccessorKv,node.left,node.right,parent = node.parent))
//                            is Node.ThreeNode      -> when(key){
//                                node.keyValue1.key -> node.replaceWith(ThreeNode(inorderSuccessorKv,node.keyValue2,    left = node.left,middle = node.middle,right = node.right,parent = node.parent))
//                                node.keyValue2.key -> node.replaceWith(ThreeNode(node.keyValue1    ,inorderSuccessorKv,left = node.left,middle = node.middle,right = node.right,parent = node.parent))
//                            }
//                        }

                    }else if(inorderSuccessorNode.isLeaf()){
                        //ThreeNode in leaf is already managed up in the code
                        val node     = node as TwoNode
                        val parent   = node.parent
                        val siblings = node.getSiblings()
                        if(siblings.hasThreeNodeSibling()){
                            when(parent){
                                is Node.TwoNode   -> {
                                    val sibling = (siblings as Sibling.OneSibling).sibling as ThreeNode
                                    when(node.getPosition()){
                                        Left   -> {
                                            parent.replaceWith(
                                                TwoNode(sibling.keyValue1,parent=parent.parent)
                                                    .addLeft(parent.keyValue1)
                                                    .addRight(sibling.keyValue2)
                                            )
                                            return true
                                        }
                                        Middle -> throw IllegalStateException("two node parent cant' have middle child")
                                        Right  -> {
                                            parent.replaceWith(
                                                TwoNode(sibling.keyValue2,parent=parent.parent)
                                                    .addLeft(sibling.keyValue1)
                                                    .addRight(parent.keyValue1)
                                            )
                                            return true
                                        }
                                    }
                                }
                                is Node.ThreeNode -> {
                                    val sibling  = siblings.closestSibling()
                                    when(node.getPosition()){
                                        Left   -> {
                                            when(sibling)
                                            {
                                                is Node.TwoNode   -> {
                                                    parent.replaceWith(
                                                        TwoNode(parent.keyValue2,parent=parent.parent)
                                                            .addLeft(ThreeNode(parent.keyValue1,sibling.keyValue1))
                                                            .addRight(parent.right!!)
                                                    )
                                                    return true
                                                }
                                                is Node.ThreeNode -> {
                                                    parent.replaceWith(
                                                        ThreeNode(sibling.keyValue1,parent.keyValue2,parent = parent.parent)
                                                            .addMiddle(sibling.keyValue2)
                                                            .addLeft(parent.keyValue1)
                                                            .addRight(parent.right!!)
                                                    )
                                                    return true
                                                }
                                            }
                                        }

                                        Middle -> {
                                            when(siblings){
                                                is Sibling.TwoSiblings -> {
                                                    if(siblings.first is ThreeNode || (siblings.first is ThreeNode && siblings.second is ThreeNode)){
                                                        parent.replaceWith(
                                                            ThreeNode((siblings.first as ThreeNode<K, V>).keyValue2,parent.keyValue2,parent=parent.parent)
                                                                .addMiddle(parent.keyValue1)
                                                                .addLeft(sibling.keyValue1)
                                                                .addRight(parent.right!!)
                                                        )
                                                        return true
                                                    }else if(siblings.first !is ThreeNode && siblings.second is ThreeNode){
                                                        parent.replaceWith(
                                                            ThreeNode(parent.keyValue1,(siblings.second as ThreeNode<K, V>).keyValue1,parent=parent.parent)
                                                                .addMiddle(parent.keyValue2)
                                                                .addLeft(parent.left!!)
                                                                .addRight((siblings.second as ThreeNode<K, V>).keyValue2)
                                                        )
                                                        return true
                                                    }

                                                }
                                            }

                                        }
                                        Right  -> {
                                            when(sibling){
                                                is Node.TwoNode -> {
                                                        parent.replaceWith(
                                                            TwoNode(parent.keyValue1,parent=parent.parent)
                                                                .addLeft(parent.left!!)
                                                                .addRight(ThreeNode(sibling.keyValue1,parent.keyValue2))
                                                        )
                                                    return true
                                                }
                                                is Node.ThreeNode -> {
                                                    parent.replaceWith(
                                                        ThreeNode(parent.keyValue1,sibling.keyValue2,parent=parent.parent)
                                                            .addMiddle(sibling.keyValue1)
                                                            .addLeft(parent.left!!)
                                                            .addRight(parent.keyValue2)
                                                    )
                                                    return true
                                                }
                                             }

                                        }
                                    }

                                }
                                null -> TODO()
                            }
                        }else {
                            when(parent){
                                is Node.TwoNode   -> {
                                    TODO()
                                }
                                is Node.ThreeNode -> {
                                    when(node.getPosition()){
                                        Left    -> {
                                            parent.replaceWith(
                                                TwoNode(parent.keyValue2,parent=parent.parent)
                                                    .addLeft(ThreeNode(parent.keyValue1,siblings.closestSibling().keyValue1))
                                                    .addRight(parent.right!!)
                                            )
                                            return true
                                        }
                                        Middle  -> {
                                            parent.replaceWith(
                                                TwoNode(parent.keyValue2,parent=parent.parent)
                                                    .addLeft(ThreeNode(siblings.closestSibling().keyValue1,parent.keyValue1))
                                                    .addRight(parent.right!!)
                                            )
                                            return true
                                        }
                                        Right   -> {
                                            parent.replaceWith(
                                                TwoNode(parent.keyValue1,parent=parent.parent)
                                                    .addLeft(parent.left!!)
                                                    .addRight(ThreeNode(siblings.closestSibling().keyValue1,parent.keyValue2))
                                            )
                                            return true
                                        }
                                    }
                                }
                                null -> TODO()
                            }
                        }
                    }

                    when(inorderSuccessorNode){
                        is Node.TwoNode   -> {
                            val siblings = inorderSuccessorNode.getSiblings()
                            if(siblings.closestSibling() is ThreeNode ){
                                val sibling = siblings.closestSibling()
                                val parent  = sibling.parent
                                when(inorderSuccessorNode.getPosition()){
                                    Left -> {
                                        TODO()
                                    }
                                    Middle -> {
                                        when(siblings){
                                            is Sibling.TwoSiblings -> {
                                                if(siblings.first is ThreeNode || (siblings.first is ThreeNode && siblings.second is ThreeNode)){
                                                    val sibling = siblings.first as ThreeNode
                                                    sibling.deleteFromNode(sibling.keyValue2.key)
                                                    sibling.parent!!.keyValue1 = sibling.keyValue2
                                                    return true
                                                }else{
                                                    TODO()
                                                }
                                            }
                                            is Sibling.OneSibling -> TODO()
                                        }
                                    }
                                    Right -> {
                                        when(parent){
                                            is Node.TwoNode   -> {
                                                //parent.replaceWith()
                                                TODO()
                                            }
                                            is Node.ThreeNode -> {
                                                if(sibling.getPosition() == Middle){
                                                    val sibling = (sibling as ThreeNode)
                                                    (sibling as ThreeNode).deleteFromNode(sibling.keyValue2.key)
                                                    parent.keyValue2=sibling.keyValue2
                                                    return true
                                                }
                                                    parent.replaceWith(
                                                        TwoNode(parent.keyValue1, parent = parent.parent)
                                                            .addLeft(parent.left!!)
                                                            .addRight(ThreeNode(parent.middle!!.keyValue1, (sibling as ThreeNode).keyValue2))
                                                    )
                                                    return true


                                            }
                                            null -> TODO()
                                        }
                                    }
                                }
                            }else{
                                val parent  = inorderSuccessorNode.parent
                                val insNode = inorderSuccessorNode
                                when(parent){
                                    is Node.TwoNode   -> TODO()
                                    is Node.ThreeNode -> {
                                        when(insNode.getPosition()){
                                            Left -> TODO()
                                            Middle -> {
                                                parent.replaceWith(
                                                    TwoNode(parent.keyValue2,parent=parent.parent)
                                                        .addLeft(ThreeNode(parent.left!!.keyValue1,insNode.keyValue1))
                                                        .addRight(parent.right!!)
                                                )
                                                return true
                                            }
                                            Right -> {
                                                parent.replaceWith(
                                                    TwoNode(parent.keyValue1,parent=parent.parent)
                                                        .addLeft (parent.left!!)
                                                        .addRight(ThreeNode(parent.middle!!.keyValue1,insNode.keyValue1))
                                                )
                                                return true
                                            }
                                        }
                                    }
                                    null -> TODO()
                                }
                            }
                        }
                        is Node.ThreeNode -> {
                            inorderSuccessorNode.deleteFromNode(inorderSuccessorKv.key)
                            return true
                        }
                    }
*/

/*
//                    if (inorderSuccessorNode.getSiblings().hasNotThreeNodeSibling()) {
//                        val parent = inorderSuccessorNode.parent
//                        if (parent is ThreeNode) {
//                            if (parent.keyValue1.key == key) {
//                                val newLeft = (parent.left as TwoNode).toThreeNode(inorderSuccessorNode.keyValue1)
//                                parent.replaceWith(TwoNode(parent.keyValue2, parent = parent.parent).addLeft(newLeft).addRight(parent.right!!))
//                                return true
//                            } else if (parent.keyValue2.key == key) {
//                                val newRight = (parent.middle as TwoNode).toThreeNode(inorderSuccessorNode.keyValue1)
//                                parent.replaceWith(TwoNode(parent.keyValue1, parent = parent.parent).addLeft(parent.left!!).addRight(newRight))
//                                return true
//
//                            }
//                        }
//                    }
//
//                    if(inorderSuccessor.parent is ThreeNode){
//                        val sibl = inorderSuccessor.getSiblings()
//                        when(inorderSuccessor.getPosition()){
//                            Position.Left -> TODO()
//                            Position.Middle -> TODO()
//                            Position.Right -> TODO()
//                        }
//                    }


                    val siblings = node.getSiblings()
                    //    if(siblings.hasThreeNodeSibling())
                    when (siblings) {
                        is Sibling.TwoSiblings<K, V> -> {
                            //if i have two siblings, my parent has to be threeNode
                            val parent = node.parent as ThreeNode
                            val position = node.getPosition()
                            when (position) {
                                Left -> {
                                    //I only care about my sibling on the right side which is in the middle one
                                    if (siblings.first is TwoNode) {
                                        val newLeftKv1 = parent.keyValue1
                                        val newLeftKv2 = siblings.first.keyValue1
                                        val parentsRightSon = parent.right!!
                                        parent.replaceWith(
                                            TwoNode(
                                                keyValue1 = parent.keyValue2,
                                                parent = parent.parent
                                            )
                                                .addLeft(ThreeNode(newLeftKv1, newLeftKv2))
                                                .addRight(parentsRightSon)
                                        )
                                        return true

                                    } else {
                                        val sibling = siblings.first as ThreeNode<K, V>
                                        val newLeftKv = parent.keyValue1
                                        val newParentKv1 = sibling.keyValue1
                                        parent.left!!.keyValue1 = newLeftKv
                                        sibling.deleteFromNode(newParentKv1.key)
                                        parent.keyValue1 = newParentKv1
                                        return true
                                    }
                                }

                                Middle -> {
                                    if (siblings.first is ThreeNode || siblings.second is ThreeNode) {
                                        if (siblings.first is ThreeNode) {
                                            val sibling = siblings.first as ThreeNode<K, V>
                                            val newMiddleKv = parent.keyValue1
                                            val newParentKv1 = sibling.keyValue2
                                            sibling.deleteFromNode(newParentKv1.key)
                                            parent.middle!!.keyValue1 = newMiddleKv
                                            parent.keyValue1 = newParentKv1
                                            return true
                                        } else {
                                            //if i'm the middle of threeNode and left is 2node and right is 3node
                                            val sibling = siblings.second as ThreeNode<K, V>
                                            val newMiddleKv = parent.keyValue2
                                            val newParentKv1 = parent.right!!.keyValue1
                                            (parent.right as ThreeNode<K, V>).deleteFromNode(newParentKv1.key)
                                            parent.middle!!.keyValue1 = newMiddleKv
                                            parent.keyValue2 = newParentKv1
                                            return true
                                        }
                                    } else {
                                        val sibling = siblings.first as TwoNode<K, V>
                                        val rightToKeep = sibling.parent!!.right!!
                                        val parentKv = parent.keyValue2
                                        val newThreeNode = ThreeNode(sibling.keyValue1, parent.keyValue1)

                                        parent.replaceWith(TwoNode(parentKv, parent = parent.parent).addLeft(newThreeNode).addRight(rightToKeep))
                                        return true
                                    }
                                }

                                Right -> {
                                    //I only care about my sibling on the left side which is in the middle one
                                    if (siblings.first is TwoNode) {
                                        val sibling = siblings.first// as ThreeNode
                                        val newRightKv1 = sibling.keyValue1
                                        val newRightKv2 = parent.keyValue2
                                        val newLeft = parent.left!!
                                        parent.replaceWith(TwoNode(
                                            keyValue1 = parent.keyValue1,
                                            parent = parent.parent
                                        )
                                            .addRight(ThreeNode(newRightKv1, newRightKv2))
                                            .addLeft(newLeft)
                                        )
                                        return true

                                    } else {
                                        val sibling = siblings.first as ThreeNode<K, V>
                                        val newRightKv = parent.keyValue2
                                        val newParentKv2 = sibling.keyValue2
                                        parent.right!!.keyValue1 = newRightKv
                                        sibling.deleteFromNode(newParentKv2.key)
                                        parent.keyValue2 = newParentKv2
                                        return true
                                    }

                                }
                            }
                        }
                        is Sibling.OneSibling -> {
                            when (siblings.side) {
                                Left -> {
                                    val sibling = siblings.sibling
                                    when (sibling) {
                                        is Node.TwoNode -> {
                                            println() //TODO()
                                        }
                                        is Node.ThreeNode -> {
                                            val newRightKV = sibling.parent!!.keyValue1
                                            val newParentKv = sibling.keyValue2 as KeyValue<K, V>
                                            (sibling as ThreeNode<K, V>).deleteFromNode(newParentKv.key)
                                            sibling.parent!!.keyValue1 = newParentKv
                                            sibling.parent!!.right!!.keyValue1 = newRightKV as KeyValue<K, V>


                                            return true
                                        }
                                    }
                                }
                                Middle -> TODO()
                                Right -> {
                                    val sibling = siblings.sibling
                                    when (sibling) {
                                        is Node.TwoNode -> TODO()
                                        is Node.ThreeNode -> {
                                            //my sibling is on right side thereofre I have twondoe parent and and I'm on the left side
                                            // left side key is parent key, and parent key is left side of the three node sibling
                                            val newLeftNode = sibling.parent
                                            val newParentKv = sibling.keyValue1
                                            val sibling = sibling as ThreeNode<K, V>

                                            sibling.replaceWith(TwoNode(keyValue1 = sibling.keyValue2, parent = sibling.parent))
                                            if (sibling.isLeaf())
                                                node.keyValue1 = newLeftNode!!.keyValue1 as KeyValue<K, V>
                                            else
                                                node.replaceWith(newLeftNode as Node<K, V>)
                                            sibling.parent!!.keyValue1 = newParentKv as KeyValue<K, V>
                                            return true
                                        }
                                        else -> throw Exception("nope")
                                    }

                                }
                            }
                        }
                        Sibling.NoSiblings<K, V>() -> TODO()
                    }



                    if (inorderSuccessorNode is ThreeNode && inorderSuccessorNode.hasKids()) {

                    }*/


